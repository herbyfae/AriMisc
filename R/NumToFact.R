NumToFact = function(data = NULL,
                     cols = NULL,
                     quantiles = NULL,
                     breaks = NULL,
                     break.names = NULL,
                     return.full = F) {

# Preprocessing -----

  if (!is.null(quantiles) & !is.null(breaks)) {
    stop("Either quantiles or breaks, not both")
  }
  if(is.null(data)){
    stop("How would I convert something you're not providing")
  }
  if(cols < 1){
    stop("Provided a negative index on 'cols', check your inputs")
  }

    data = as.data.frame(data)

  if(is.null(cols) & ncol(data)>1){
    warning("Data given but numerical column not specified -> All numerical columns converted")
  }

    if (!is.null(cols)) {  ## Data given + columns(index or name) ----

      if (length(cols) > ncol(data)) {
        stop("Given more indexes than there are columns in the data")
      } else if(cols > ncol(data)){
        stop("Given an index higher than there are columns in the data")
      } else{
        if(return.full){ # Have to keep the data intact because this option exists
          index = cols    # -> cols receives what's necessary
        }                 # (just to not have another tag to keep track of)

        cols = data[, cols]

        if(sum(!unlist(lapply(cols, is.numeric))) > 0){

          warning("Detected columns selected by cols that weren't numeric - kept only those that were")
          if(return.full){
            index = index[unlist(lapply(cols, is.numeric))]
          }
          cols = cols[,unlist(lapply(cols, is.numeric))]
        }

      }
    } else{ ## Data given but no columns specified -----

      cols = data[, unlist(lapply(data, is.numeric))] # Extracts numerical columns
      if(return.full){
        index = colnames(cols)
      }
    }


  cols = as.data.frame(cols)

# Breaks cycles -----
  if (!is.null(breaks)) {

    breaks = breaks[order(breaks)]

    for(j in 1:ncol(cols)){

      str.cols = cols[j]

  ## Setting up names + 1st autogenerated -----
      if(!is.null(break.names)){
        if(length(break.names) != (length(breaks) + 1)){
          stop("There should be one name for each new level(length of breaks + 1)")
        }
        quant.levels = break.names
      } else{
        quant.levels = NULL
        quant.levels[1] = paste("<=", as.character(breaks)[1], sep = "")
      }

      str.cols[which(cols[j] <= breaks[1]),1] = quant.levels[1]

  ## Up to the last break -----
      if(length(breaks) > 1){
        for (i in 2:length(breaks)) {

          if(is.null(break.names)){
            quant.levels[i] = paste(as.character(breaks[i - 1]), "-",
                                                  as.character(breaks[i]), sep = "")
          }
          str.cols[which(cols[j] <= breaks[i] &
                          cols[j] > breaks[i - 1]),1] = quant.levels[i]

        }
      }
  ## Final level(s) -----
      if(is.null(break.names)){
        quant.levels[(length(breaks) + 1)] = paste(">", as.character(breaks)[length(breaks)], sep = "")
      }

      str.cols[which(cols[j] > breaks[length(breaks)]),1] = quant.levels[(length(breaks) + 1)]
  ## If there are NAs make them a level
      if(sum(is.na(cols[j]))>0){
        warning(paste("Given cols has NAs - Col_", j, "(", colnames(data)[j],")" ,sep = "" ))
        str.cols[is.na(cols[j])] = "NA"
        quant.levels[(length(breaks) + 2)] = "NA"
      }

      cols[j] = factor(str.cols[,1], levels = unique(quant.levels))
    }                                      # Allow you to join levels
  } else {  # Quantile setup -----
    if (!is.null(quantiles)) {
      quantiles = as.numeric(quantiles)
      quantiles[order(quantiles, decreasing = F)]

      if(sum(quantiles <= 0) > 0|sum(quantiles >= 100) > 0){
        stop("Detected a number under 0 or over 100 in the quantiles - Unable to convert to 0-1 quantiles")
      } else if(sum(quantiles >= 1) > 0){
        quantiles = quantiles/100
        if(sum(quantiles < 0.01) > 0){
          warning("Converted quantiles have at least one element under 1%, check your values")
        }
      }

    } else{
      quantiles = c(0.25,0.5,0.75) # Default quartiles
    }
 # Quantile cycles -----
    for(j in 1:ncol(cols)){

      str.cols = cols[j]
 ## Setting up names + 1st autogenerated -----
      if(!is.null(break.names)){
        if(length(break.names) != (length(quantiles) + 1)){
          stop("There should be one name for each new level(length of quantiles + 1)")
        }
        quant.levels = break.names
      } else{
        quant.levels = NULL
        quant.levels[1] = paste("<=Q", quantiles[1], sep = "")
      }

      str.cols[which(cols[j] <= quantile(cols[j], quantiles[1], na.rm = T)),1] = quant.levels[1]
 ## Up to the last quantile -----
      for (i in 2:length(quantiles)) {

        if (is.null(break.names)) {
          quant.levels[i] =  paste("Q", quantiles[i - 1], "-",
                                   "Q", quantiles[i],
                                   sep = "")

        }
        str.cols[which(cols[j] <= quantile(cols[j], quantiles[i], na.rm = T) &
                        cols[j] > quantile(cols[j], quantiles[i - 1], na.rm = T)),1] = quant.levels[i]

      }
 ## Final level(s) ----
      if (is.null(break.names)) {
        quant.levels[(length(quantiles) + 1)] = paste(">Q", quantiles[length(quantiles)], sep = "")
      }

      str.cols[which(cols[j] > quantile(cols[j], quantiles[length(quantiles)], na.rm = T)),1] =
        quant.levels[(length(quantiles) + 1)]

      if(sum(is.na(cols[j]))>0){
        warning(paste("Given cols has NAs - Col_", j, "(", colnames(data)[j],")" ,sep = "" ))
        str.cols[is.na(cols[j])] = "NA"
        quant.levels[(length(quantiles) + 2)] = "NA"
      }

      cols[j] = factor(str.cols[,1], levels = unique(quant.levels))

    }
  }

  if(return.full){
    data[,index] = cols
    cols = data
  }

  return(cols)

}
